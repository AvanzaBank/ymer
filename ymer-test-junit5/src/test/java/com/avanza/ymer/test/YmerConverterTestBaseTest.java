/*
 * Copyright 2015 Avanza Bank AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.avanza.ymer.test;

import static java.util.Collections.emptyList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.anything;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.not;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.fail;

import java.time.LocalDate;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.MongoDbFactory;
import org.springframework.data.mongodb.core.convert.DefaultDbRefResolver;
import org.springframework.data.mongodb.core.convert.MappingMongoConverter;
import org.springframework.data.mongodb.core.convert.MongoConverter;
import org.springframework.data.mongodb.core.convert.MongoCustomConversions;
import org.springframework.data.mongodb.core.mapping.MongoMappingContext;

import com.avanza.ymer.MirroredObjectDefinition;
import com.avanza.ymer.support.JavaLocalDateReadConverter;
import com.avanza.ymer.support.JavaLocalDateWriteConverter;
import com.avanza.ymer.test.YmerConverterTestBase.ConverterTest;
import com.gigaspaces.annotation.pojo.SpaceId;

class YmerConverterTestBaseTest {

	@Test
	void testingIfMirroredObjectIsMirroredPasses() {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(new TestSpaceObject("foo", "message")));
		assertPasses(() -> test1.canMirrorSpaceObject(test1.converterTest));
	}

	@Test
	void testingIfNonMirroredObjectIsMirroredFails() {
		class NonMirroredType {

		}
		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(new NonMirroredType()));
		assertFails(() -> test1.canMirrorSpaceObject(test1.converterTest));
	}

	@Test
	void serializationTestSucceeds() {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObject("foo", "message"), anything()));
		assertPasses(() -> test1.serializationTest(test1.converterTest));
	}

	@Test
	void serializationTestFails() {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObject("foo", "message"), not(anything())));
		assertFails(() -> test1.serializationTest(test1.converterTest));
	}

	@Test
	void nestedSpaceObjectSerializationComparisonSucceeds() {
		final TestNestedSpaceClass nestedObject = new TestNestedSpaceClass();
		nestedObject.setId("test");
		nestedObject.setNestedClass(new TestNestedSpaceClass.NestedClass(123, LocalDate.parse("2021-01-01")));

		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(nestedObject), List.of(
				new JavaLocalDateReadConverter(),
				new JavaLocalDateWriteConverter()
		));
		assertPasses(() -> test1.serializationTest(test1.converterTest));
	}

	@Test
	void nestedSpaceObjectSerializationComparisonFails() {
		final TestNestedSpaceClass nestedObject = new TestNestedSpaceClass();
		nestedObject.setId("test");
		nestedObject.setNestedClass(new TestNestedSpaceClass.NestedClass(123, LocalDate.parse("2021-01-01")));

		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(nestedObject), List.of(
				new JavaLocalDateReadConverter(),
				new JavaLocalDateWriteConverter() {
					// make sure conversion fails to convert object properly
					@Override
					public String convert(LocalDate localDate) {
						return "2021-12-31";
					}
				}
		));
		assertFailsWithAssertionErrorContaining(() -> test1.serializationTest(test1.converterTest), "field/property 'nestedClass.date' differ");
	}

	@Test
	void spaceObjectWithoutIdAnnotationTestFails() {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectWithoutSpringDataIdAnnotation("foo"), anything()));
		assertFails(() -> test1.testFailsIfSpringDataIdAnnotationNotDefinedForSpaceObject(test1.converterTest));
	}

	@Test
	void spaceObjectWithEmptyIdAndAutogeneratedSpaceIdSucceeds() {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectAutogeneratedId(), anything()));
		assertPasses(() -> test1.testFailsIfSpringDataIdAnnotationNotDefinedForSpaceObject(test1.converterTest));
	}

	@Test
	void spaceObjectWithEmptyCollectionTestFails() {
		final YmerConverterTestCase test = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectWithEmptyCollection(), anything()));

		assertFails(() -> test.testFailsIfSpringDataIdAnnotationNotDefinedForSpaceObject(test.converterTest));
	}

	@Test
	void spaceObjectWithEmptyMapTestFails() {
		final YmerConverterTestCase test = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectWithEmptyMap(), anything()));

		assertFails(() -> test.testFailsIfCollectionOrMapPropertyOfTestSubjectIsEmpty(test.converterTest));
	}

	private static class YmerConverterTestCase extends YmerConverterTestBase {

		private final ConverterTest<?> converterTest;
		private final List<?> mongoConverters;

		YmerConverterTestCase(ConverterTest<?> testCase, List<?> mongoConverters) {
			this.converterTest = testCase;
			this.mongoConverters = mongoConverters;
		}

		public YmerConverterTestCase(ConverterTest<?> testCase) {
			this(testCase, emptyList());
		}

		@Override
		protected Collection<MirroredObjectDefinition<?>> getMirroredObjectDefinitions() {
			return List.of(MirroredObjectDefinition.create(converterTest.spaceObject.getClass()));
		}

		@Override
		protected MongoConverter createMongoConverter(MongoDbFactory mongoDbFactory) {
			MappingMongoConverter mongoConverter = new MappingMongoConverter(new DefaultDbRefResolver(mongoDbFactory), new MongoMappingContext());
			mongoConverter.setCustomConversions(new MongoCustomConversions(mongoConverters));
			return mongoConverter;
		}

		@Override
		protected Collection<ConverterTest<?>> testCases() {
			return List.of(converterTest);
		}
	}

	static class TestSpaceObjectWithEmptyCollection {
		@Id
		String id;

		Collection<String> emptyCollection = Collections.emptyList();

		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}

		public Collection<String> getEmptyCollection() {
			return emptyCollection;
		}

		public void setEmptyCollection(Collection<String> emptyCollection) {
			this.emptyCollection = emptyCollection;
		}

	}

	static class TestSpaceObjectWithEmptyMap {
		@Id
		String id;

		Map<String, String> map = Collections.emptyMap();

		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}

		public Map<String, String> getMap() {
			return map;
		}

		public void setMap(Map<String, String> emptyCollection) {
			this.map = emptyCollection;
		}

	}

	static class TestSpaceObjectWithoutSpringDataIdAnnotation {

		public TestSpaceObjectWithoutSpringDataIdAnnotation(String id) {
			this.identifier = id;
		}

		private String identifier;

		@SpaceId
		public String getIdentifier() {
			return identifier;
		}

		public void setIdentifier(String id) {
			this.identifier = id;
		}
	}

	static class TestSpaceObjectAutogeneratedId {

		@Id
		private String identifier;

		@SpaceId(autoGenerate = true)
		public String getIdentifier() {
			return identifier;
		}

		public void setIdentifier(String id) {
			this.identifier = id;
		}
	}

	static class TestNestedSpaceClass {
		@Id
		String id;

		private NestedClass nestedClass;

		@SpaceId
		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}

		public NestedClass getNestedClass() {
			return nestedClass;
		}

		public void setNestedClass(NestedClass nestedClass) {
			this.nestedClass = nestedClass;
		}

		static class NestedClass {
			private final int id;
			private final LocalDate date;

			public NestedClass(int id, LocalDate date) {
				this.id = id;
				this.date = date;
			}
		}

	}

	private static void assertFails(Executable testRun) {
		assertThrows(Throwable.class, testRun);
	}

	private static void assertFailsWithAssertionErrorContaining(Executable testRun, String messageContaining) {
		AssertionError ae = assertThrows(AssertionError.class, testRun);
		assertThat(ae.getMessage(), containsString(messageContaining));
	}

	private static void assertPasses(Runnable testRun) {
		try {
			testRun.run();
		} catch (AssertionError e) {
			fail("Expected test to pass, but failed with: " + e.getMessage());
		}
	}

}
