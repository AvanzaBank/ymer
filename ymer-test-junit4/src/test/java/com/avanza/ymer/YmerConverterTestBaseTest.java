/*
 * Copyright 2015 Avanza Bank AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.avanza.ymer;

import static java.util.Collections.emptyList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.anything;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.fail;

import java.time.LocalDate;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.junit.Test;
import org.junit.function.ThrowingRunnable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.annotation.Id;

import com.avanza.ymer.YmerConverterTestBase.ConverterTest;
import com.avanza.ymer.support.JavaLocalDateReadConverter;
import com.avanza.ymer.support.JavaLocalDateWriteConverter;
import com.gigaspaces.annotation.pojo.SpaceId;

public class YmerConverterTestBaseTest {

	private static final Logger log = LoggerFactory.getLogger(YmerConverterTestBaseTest.class);

	@Test
	public void testingIfMirroredObjectIsMirroredPasses() throws Exception {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(new TestSpaceObject("foo", "message")));
		assertPasses(test1::canMirrorSpaceObject);
	}

	@Test
	public void testingIfNonMirroredObjectIsMirroredFails() throws Exception {
		class NonMirroredType {

		}
		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(new NonMirroredType()));
		assertFails(test1::canMirrorSpaceObject);
	}

	@Test
	public void serializationTestSucceeds() throws Exception {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObject("foo", "message"), anything()));
		assertPasses(test1::serializationTest);
	}

	@Test
	public void serializationTestFails() throws Exception {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObject("foo", "message"), not(anything())));
		assertFails(test1::serializationTest);
	}

	@Test
	public void nestedSpaceObjectSerializationComparisonSucceeds() {
		final TestNestedSpaceClass nestedObject = new TestNestedSpaceClass();
		nestedObject.setId("test");
		nestedObject.setNestedClass(new TestNestedSpaceClass.NestedClass(123, LocalDate.parse("2021-01-01")));

		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(nestedObject), List.of(
				new JavaLocalDateReadConverter(),
				new JavaLocalDateWriteConverter()
		));
		assertPasses(test1::serializationTest);
	}

	@Test
	public void nestedSpaceObjectSerializationComparisonFails() {
		final TestNestedSpaceClass nestedObject = new TestNestedSpaceClass();
		nestedObject.setId("test");
		nestedObject.setNestedClass(new TestNestedSpaceClass.NestedClass(123, LocalDate.parse("2021-01-01")));

		final YmerConverterTestCase test1 = new YmerConverterTestCase(new ConverterTest<>(nestedObject), List.of(
				new JavaLocalDateReadConverter(),
				new JavaLocalDateWriteConverter() {
					// make sure conversion fails to convert object properly
					@Override
					public String convert(LocalDate localDate) {
						return "2021-12-31";
					}
				}
		));
		assertFailsWithAssertionErrorContaining(test1::serializationTest, "field/property 'nestedClass.date' differ");
	}


	@Test
	public void spaceObjectWithoutIdAnnotationTestFails() throws Exception {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectWithoutSpringDataIdAnnotation("foo"), anything()));
		assertFails(test1::testFailsIfSpringDataIdAnnotationNotDefinedForSpaceObject);
	}

	@Test
	public void spaceObjectWithEmptyIdAndAutogeneratedSpaceIdSucceeds() throws Exception {
		final YmerConverterTestCase test1 = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectAutogeneratedId(), anything()));
		assertPasses(test1::testFailsIfSpringDataIdAnnotationNotDefinedForSpaceObject);
	}

	@Test
	public void spaceObjectWithEmptyCollectionTestFails() throws Exception {
		final YmerConverterTestCase test = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectWithEmptyCollection(), anything()));

		assertFails(test::testFailsIfCollectionOrMapPropertyOfTestSubjectIsEmpty);
	}

	@Test
	public void spaceObjectWithEmptyMapTestFails() throws Exception {
		final YmerConverterTestCase test = new YmerConverterTestCase(
				new ConverterTest<>(new TestSpaceObjectWithEmptyMap(), anything()));

		assertFails(test::testFailsIfCollectionOrMapPropertyOfTestSubjectIsEmpty);
	}

	@Test
	public void shouldRequireAnnotationsOnCustomConverters() {
		// Arrange
		final var test = new YmerConverterTestCase(
				new ConverterTest<>(new Object()),
				List.of(new ReadingConverterWithoutAnnotation())
		);

		// Act
		Throwable expected = assertThrows(AssertionError.class, test::shouldRequireAnnotationsOnCustomConverters);

		// Assert
		assertThat(expected.getMessage(), containsString(ReadingConverterWithoutAnnotation.class.getName()));
		assertThat(expected.getMessage(), containsString("should be annotated with either @ReadingConverter or @WritingConverter"));
	}

	private static class YmerConverterTestCase extends YmerConverterTestBase {

		private final MirroredObjectsConfiguration mirroredObjectsConfiguration;

		YmerConverterTestCase(ConverterTest<?> testCase, List<Converter<?, ?>> mongoConverters) {
			super(testCase);
			var spaceClass = testCase.spaceObject.getClass();
			List<MirroredObjectDefinition<?>> mirroredObjectDefinitions = List.of(MirroredObjectDefinition.create(spaceClass));
			this.mirroredObjectsConfiguration = new MirroredObjectsConfiguration() {
				@Override
				public Collection<MirroredObjectDefinition<?>> getMirroredObjectDefinitions() {
					return mirroredObjectDefinitions;
				}

				@Override
				public List<Converter<?, ?>> getCustomConverters() {
					return mongoConverters;
				}
			};
		}

		public YmerConverterTestCase(ConverterTest<?> testCase) {
			this(testCase, emptyList());
		}

		@Override
		protected MirroredObjectsConfiguration getMirroredObjectsConfiguration() {
			return mirroredObjectsConfiguration;
		}
	}

	public static class TestSpaceObjectWithEmptyCollection {
		@Id
		String id;

		Collection<String> emptyCollection = emptyList();

		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}

		public Collection<String> getEmptyCollection() {
			return emptyCollection;
		}

		public void setEmptyCollection(Collection<String> emptyCollection) {
			this.emptyCollection = emptyCollection;
		}

	}

	public static class TestSpaceObjectWithEmptyMap {
		@Id
		String id;

		Map<String, String> map = Collections.emptyMap();

		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}

		public Map<String, String> getMap() {
			return map;
		}

		public void setMap(Map<String, String> emptyCollection) {
			this.map = emptyCollection;
		}

	}

	public static class TestSpaceObjectWithoutSpringDataIdAnnotation {

		public TestSpaceObjectWithoutSpringDataIdAnnotation() {
		}

		public TestSpaceObjectWithoutSpringDataIdAnnotation(String id) {
			this.identifier = id;
		}

		private String identifier;

		@SpaceId
		public String getIdentifier() {
			return identifier;
		}

		public void setIdentifier(String id) {
			this.identifier = id;
		}
	}

	public static class TestSpaceObjectAutogeneratedId {

		@Id
		private String identifier;

		@SpaceId(autoGenerate = true)
		public String getIdentifier() {
			return identifier;
		}

		public void setIdentifier(String id) {
			this.identifier = id;
		}
	}

	public static class TestNestedSpaceClass {
		@Id
		String id;

		private NestedClass nestedClass;

		@SpaceId
		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}

		public NestedClass getNestedClass() {
			return nestedClass;
		}

		public void setNestedClass(NestedClass nestedClass) {
			this.nestedClass = nestedClass;
		}

		static class NestedClass {
			private final int id;
			private final LocalDate date;

			public NestedClass(int id, LocalDate date) {
				this.id = id;
				this.date = date;
			}

			public int getId() {
				return id;
			}

			public LocalDate getDate() {
				return date;
			}
		}

	}

	// This class is intentionally missing @ReadingConverter annotation
	static class ReadingConverterWithoutAnnotation implements Converter<String, Long> {
		@Override
		public Long convert(String source) {
			return 1L;
		}
	}

	private static void assertFails(ThrowingRunnable testRun) {
		Throwable exception = assertThrows("Expected test to fail", Throwable.class, testRun);

		if (!(exception instanceof AssertionError)) {
			log.trace("Exception executing testRun", exception);
		}
	}

	private static void assertFailsWithAssertionErrorContaining(ThrowingRunnable testRun, String messageContaining) {
		AssertionError ae = assertThrows(AssertionError.class, testRun);
		assertThat(ae.getMessage(), containsString(messageContaining));
	}

	private static void assertPasses(Runnable testRun) {
		try {
			testRun.run();
		} catch (AssertionError e) {
			fail("Expected test to pass, but failed with \"" + e.getMessage() + "\"");
		}
	}

}
